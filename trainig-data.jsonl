{"prompt": "List all necessary imports for basic entities and components in a Decentraland scene.", "completion": "import { Quaternion, Vector3 } from '@dcl/sdk/math'\\nimport {\\n  Animator,\\n  AudioSource,\\n  AvatarAttach,\\n  GltfContainer,\\n  Material,\\n  Transform,\\n  VideoPlayer,\\n  VisibilityComponent,\\n  engine,\\n  pointerEventsSystem\\n} from '@dcl/sdk/ecs'"}
{"prompt": "How do you create a new entity and assign components to it in a Decentraland scene?", "completion": "export function main() {\\n    // Entity creation and component assignment pattern\\n    const entity = engine.addEntity();\\n    Transform.create(entity, { position: Vector3.create(x, y, z) });\\n    GltfContainer.create(entity, { src: 'model/path.glb' });\\n}"}
{"prompt": "How do you remove a single entity from a Decentraland scene?", "completion": "engine.removeEntity(entity);"}
{"prompt": "How do you assign a parent to an entity in a Decentraland scene?", "completion": "Transform.create(childEntity, { parent: parentEntity });"}
{"prompt": "How do you access and modify a component of an entity in a Decentraland scene?", "completion": "const mutableTransform = Transform.getMutable(entity);\\nmutableTransform.scale.x = 5;"}
{"prompt": "How do you fetch an entity by its name in a Decentraland scene?", "completion": "const namedEntity = engine.getEntityOrNullByName('entityName');"}
{"prompt": "Create an entity and assign it a Transform and GltfContainer component with specific properties.", "completion": "const entity = engine.addEntity();\\nTransform.create(entity, { position: Vector3.create(x, y, z) });\\nGltfContainer.create(entity, { src: 'model/path.glb' });"}
{"prompt": "How do you create an entity and assign it Transform and GltfContainer components with specific properties?", "completion": "export function main() {\\n    const entity = engine.addEntity();\\n    Transform.create(entity, { position: Vector3.create(x, y, z) });\\n    GltfContainer.create(entity, { src: 'model/path.glb' });\\n}"}
{"prompt": "Create an entity with a Transform and GltfContainer component specifying position and model path.", "completion": "export function main() {\\n    const entity = engine.addEntity();\\n    Transform.create(entity, { position: Vector3.create(x, y, z) });\\n    GltfContainer.create(entity, { src: 'model/path.glb' });\\n}"}
{"prompt": "How do you remove a single entity from the engine?", "completion": "engine.removeEntity(entity);"}
{"prompt": "Remove an entity from the scene.", "completion": "engine.removeEntity(entity);"}
{"prompt": "How can you remove an entity and all of its children in Decentraland?", "completion": "removeEntityWithChildren(engine, parentEntity);"}
{"prompt": "Write the command to remove an entity along with its child entities.", "completion": "removeEntityWithChildren(engine, parentEntity);"}
{"prompt": "How do you assign a parent to an entity using the Transform component?", "completion": "Transform.create(childEntity, { parent: parentEntity });"}
{"prompt": "Assign a parent entity to a child entity.", "completion": "Transform.create(childEntity, { parent: parentEntity });"}
{"prompt": "How can a child entity be separated from its parent in the scene?", "completion": "Transform.getMutable(childEntity).parent = engine.RootEntity;"}
{"prompt": "Separate a child entity from its parent.", "completion": "Transform.getMutable(childEntity).parent = engine.RootEntity;"}
{"prompt": "How do you access a read-only version of a component of an entity?", "completion": "const transform = Transform.get(entity);"}
{"prompt": "Access a component of an entity in a read-only mode.", "completion": "const transform = Transform.get(entity);"}
{"prompt": "How can you modify a component of an entity?", "completion": "const mutableTransform = Transform.getMutable(entity);\\nmutableTransform.scale.x = 5;"}
{"prompt": "Modify the scale of a Transform component of an entity.", "completion": "const mutableTransform = Transform.getMutable(entity);\\nmutableTransform.scale.x = 5;"}
{"prompt": "How do you fetch an entity by its name in Decentraland?", "completion": "const namedEntity = engine.getEntityOrNullByName('entityName');"}
{"prompt": "Fetch an entity by name.", "completion": "const namedEntity = engine.getEntityOrNullByName('entityName');"}
{"prompt": "How do you add or replace a component to an entity to avoid duplication errors?", "completion": "Transform.createOrReplace(entity, { position: Vector3.create(x, y, z) });"}
{"prompt": "Add or replace a Transform component to an entity specifying its position.", "completion": "Transform.createOrReplace(entity, { position: Vector3.create(x, y, z) });"}
{"prompt": "How can you check if an entity has a specific component in Decentraland?", "completion": "const hasTransform = Transform.has(entity);"}
{"prompt": "Check if an entity is equipped with a Transform component.", "completion": "const hasTransform = Transform.has(entity);"}
{"prompt": "How do you remove a specific component from an entity?", "completion": "Transform.deleteFrom(entity);"}
{"prompt": "Remove a Transform component from an entity.", "completion": "Transform.deleteFrom(entity);"}
{"prompt": "How do you declare a basic system and add it to the engine in Decentraland?", "completion": "function mySystem() {\\n  console.log('Performed on every tick. My system is running');\\n}\\nengine.addSystem(mySystem);"}
{"prompt": "List necessary imports for basic entities and components in a Decentraland scene.", "completion": "import { Vector3 } from '@dcl/sdk/math';\\nimport {\\n  Animator,\\n  AudioSource,\\n  AvatarAttach,\\n  GltfContainer,\\n  Material,\\n  Transform,\\n  VideoPlayer,\\n  VisibilityComponent,\\n  engine,\\n  pointerEventsSystem\\n} from '@dcl/sdk/ecs';"}
{"prompt": "Place a 3D model in the scene.", "completion": "export function main() {\\n    const entity = engine.addEntity();\\n    Transform.create(entity, { position: Vector3.create(x, y, z) });\\n    GltfContainer.create(entity, { src: 'model/path.glb' });\\n}"}
{"prompt": "Remove an entity from the scene.", "completion": "engine.removeEntity(entity);"}
{"prompt": "Assign a parent to an entity.", "completion": "Transform.create(childEntity, { parent: parentEntity });"}
{"prompt": "Access and modify a component of an entity.", "completion": "const mutableTransform = Transform.getMutable(entity);\\nmutableTransform.scale.x = 5;"}
{"prompt": "Fetch an entity by its name.", "completion": "const namedEntity = engine.getEntityOrNullByName('entityName');"}
{"prompt": "Place a 3D model in the scene.", "completion": "const entity = engine.addEntity();\\nTransform.create(entity, { position: Vector3.create(x, y, z) });\\nGltfContainer.create(entity, { src: 'model/path.glb' });"}
{"prompt": "Place a 3D model in the scene.", "completion": "export function main() {\\n    const entity = engine.addEntity();\\n    Transform.create(entity, { position: Vector3.create(x, y, z) });\\n    GltfContainer.create(entity, { src: 'model/path.glb' });\\n}"}
{"prompt": "Remove an entity from the scene.", "completion": "engine.removeEntity(entity);"}
{"prompt": "Remove an entity and all of its children in Decentraland.", "completion": "removeEntityWithChildren(engine, parentEntity);"}
{"prompt": "Remove an entity along with its child entities.", "completion": "removeEntityWithChildren(engine, parentEntity);"}
{"prompt": "Assign a parent entity to a child entity.", "completion": "Transform.create(childEntity, { parent: parentEntity });"}
{"prompt": "Separate a child entity from its parent.", "completion": "Transform.getMutable(childEntity).parent = engine.RootEntity;"}
{"prompt": "Access a read-only version of a component of an entity.", "completion": "const transform = Transform.get(entity);"}
{"prompt": "Access a component of an entity in read-only mode.", "completion": "const transform = Transform.get(entity);"}
{"prompt": "Modify a component of an entity.", "completion": "const mutableTransform = Transform.getMutable(entity);\\nmutableTransform.scale.x = 5;"}
{"prompt": "Modify the scale of a Transform component of an entity.", "completion": "const mutableTransform = Transform.getMutable(entity);\\nmutableTransform.scale.x = 5;"}
{"prompt": "Fetch an entity by name.", "completion": "const namedEntity = engine.getEntityOrNullByName('entityName');"}
{"prompt": "Fetch an entity by name.", "completion": "const namedEntity = engine.getEntityOrNullByName('entityName');"}
{"prompt": "Add or replace a component to an entity to avoid duplication errors.", "completion": "Transform.createOrReplace(entity, { position: Vector3.create(x, y, z) });"}
{"prompt": "Add or replace a Transform component to an entity specifying its position.", "completion": "Transform.createOrReplace(entity, { position: Vector3.create(x, y, z) });"}
{"prompt": "Check if an entity has a specific component in Decentraland.", "completion": "const hasTransform = Transform.has(entity);"}
{"prompt": "Check if an entity has a Transform component.", "completion": "const hasTransform = Transform.has(entity);"}
{"prompt": "Remove a specific component from an entity.", "completion": "Transform.deleteFrom(entity);"}
{"prompt": "Remove a Transform component from an entity.", "completion": "Transform.deleteFrom(entity);"}
{"prompt": "Declare a basic system and add it to the engine in Decentraland.", "completion": "function mySystem() {\\n  console.log('Performed on every tick. My system is running');\\n}\\nengine.addSystem(mySystem);"}
{"prompt": "Declare a system that logs a message every tick and add it to the engine.", "completion": "function mySystem() {\\n  console.log('Performed on every tick. My system is running');\\n}\\nengine.addSystem(mySystem);"}
{"prompt": "How do you create a system that moves entities with the Transform component, using delta time for consistent movement?", "completion": "function moveSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(Transform)) {\\n    const transform = Transform.getMutable(entity);\\n    transform.position.z += 0.01 * dt;\\n  }\\n}\\nengine.addSystem(moveSystem);"}
{"prompt": "Create a system that applies consistent movement to entities with the Transform component.", "completion": "function moveSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(Transform)) {\\n    const transform = Transform.getMutable(entity);\\n    transform.position.z += 0.01 * dt;\\n  }\\n}\\nengine.addSystem(moveSystem);"}
{"prompt": "How do you implement and add a system to update and log the score component of an entity?", "completion": "export function main(){\\n  const game = engine.addEntity();\\n  ScoreComponent.create(game);\\n}\\nexport function UpdateScore() {\\n  const points = ScoreComponent.get(game).points;\\n  console.log(points);\\n}\\nengine.addSystem(UpdateScore);"}
{"prompt": "Implement a system for updating and logging the score of a game entity.", "completion": "export function main(){\\n  const game = engine.addEntity();\\n  ScoreComponent.create(game);\\n}\\nexport function UpdateScore() {\\n  const points = ScoreComponent.get(game).points;\\n  console.log(points);\\n}\\nengine.addSystem(UpdateScore);"}
{"prompt": "How do you design a physics system that operates on entities with a specific component, using component queries for efficiency?", "completion": "export function PhysicsSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(HasPhysics)) {\\n    const transform = Transform.getMutable(entity);\\n    // Physics calculations here\\n  }\\n}\\nengine.addSystem(PhysicsSystem);"}
{"prompt": "Design a system that performs physics calculations on entities with a specific component.", "completion": "export function PhysicsSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(HasPhysics)) {\\n    const transform = Transform.getMutable(entity);\\n    // Physics calculations here\\n  }\\n}\\nengine.addSystem(PhysicsSystem);"}
{"prompt": "How can you implement a system that executes actions at regular time intervals using a timer?", "completion": "let timer = 10;\\nfunction LoopSystem(dt: number) {\\n  timer -= dt;\\n  if (timer <= 0) {\\n    timer = 10; // Reset timer\\n    // DO SOMETHING periodically\\n  }\\n}\\nengine.addSystem(LoopSystem);"}
{"prompt": "Implement a loop system that performs certain actions periodically based on a timer.", "completion": "let timer = 10;\\nfunction LoopSystem(dt: number) {\\n  timer -= dt;\\n  if (timer <= 0) {\\n    timer = 10; // Reset timer\\n    // DO SOMETHING periodically\\n  }\\n}\\nengine.addSystem(LoopSystem);"}
{"prompt": "How do you set the execution order of systems in Decentraland by specifying priorities?", "completion": "engine.addSystem(PhysicsSystem, 1);\\nengine.addSystem(BoundariesSystem, 5);"}
{"prompt": "Set the execution order for the PhysicsSystem and BoundariesSystem with specific priorities.", "completion": "engine.addSystem(PhysicsSystem, 1);\\nengine.addSystem(BoundariesSystem, 5);"}
{"prompt": "How do you remove a previously added system from the engine by its name?", "completion": "engine.addSystem(mySystem, 1, 'mySystemName');\\nengine.removeSystem('mySystemName');"}
{"prompt": "Remove a system from the engine using its name identifier.", "completion": "engine.addSystem(mySystem, 1, 'mySystemName');\\nengine.removeSystem('mySystemName');"}
{"prompt": "Explain the use of the Boolean type in schema fields.", "completion": "Schemas.Boolean is used to define fields that can hold a true or false value."}
{"prompt": "Describe how to use the Byte type within schema fields.", "completion": "Schemas.Byte is utilized for fields that store byte values, which are integers from 0 to 255."}
{"prompt": "What is the purpose of the Double type in schemas?", "completion": "Schemas.Double is used for fields that require double precision floating-point numbers."}
{"prompt": "How is the Float type used in defining schema fields?", "completion": "Schemas.Float defines fields that hold single precision floating-point numbers."}
{"prompt": "Define the use of the Int type in schemas.", "completion": "Schemas.Int is used for fields that store 32-bit integer values."}
{"prompt": "When should you use the Int64 type in schema fields?", "completion": "Schemas.Int64 is designed for fields that need to store 64-bit integer values."}
{"prompt": "What does the Number type represent in schema definitions?", "completion": "Schemas.Number can be used for fields that require numeric values without specifying the precision."}
{"prompt": "Explain the Short type's role within schema fields.", "completion": "Schemas.Short is intended for fields that store 16-bit integer values."}
{"prompt": "How do you incorporate the String type in schema fields?", "completion": "Schemas.String is used for fields that will hold text values."}
{"prompt": "Describe the purpose of the Entity type in schemas.", "completion": "Schemas.Entity is used for fields that reference other entities."}
{"prompt": "Explain how the Vector3 type is structured and used in schemas.", "completion": "Schemas.Vector3 is a complex type for fields that represent a 3D vector with x, y, and z numerical properties."}
{"prompt": "What is the Quaternion type, and how is it used in schemas?", "completion": "Schemas.Quaternion is a complex type for fields representing rotations with x, y, z, and w numerical properties."}
{"prompt": "Describe the Color3 type and its application in schemas.", "completion": "Schemas.Color3 is a complex type for fields that define colors using three numerical values: red, green, and blue."}
{"prompt": "How does the Color4 type differ from Color3, and what is its use case?", "completion": "Schemas.Color4 is a complex type similar to Color3 but includes an additional alpha (transparency) value, using four numerical values for red, green, blue, and alpha."}
{"prompt": "How do you define a new component with a schema in Decentraland?", "completion": "export const WheelSpinComponent = engine.defineComponent('wheelSpinComponent', {\\n  spinning: Schemas.Boolean,\\n  speed: Schemas.Float\\n});"}
{"prompt": "Define a component called WheelSpinComponent with spinning and speed properties.", "completion": "export const WheelSpinComponent = engine.defineComponent('wheelSpinComponent', {\\n  spinning: Schemas.Boolean,\\n  speed: Schemas.Float\\n});"}
{"prompt": "How do you create instances of a component for entities?", "completion": "const wheel = engine.addEntity();\\nWheelSpinComponent.create(wheel, {\\n  spinning: true,\\n  speed: 10\\n});\\nconst wheel2 = engine.addEntity();\\nWheelSpinComponent.create(wheel2, {\\n  spinning: false,\\n  speed: 0\\n});"}
{"prompt": "Create two entities with WheelSpinComponent instances, one spinning at speed 10 and the other not spinning.", "completion": "const wheel = engine.addEntity();\\nWheelSpinComponent.create(wheel, {\\n  spinning: true,\\n  speed: 10\\n});\\nconst wheel2 = engine.addEntity();\\nWheelSpinComponent.create(wheel2, {\\n  spinning: false,\\n  speed: 0\\n});"}
{"prompt": "How do you access and delete component instances from an entity?", "completion": "const readOnlyInstance = WheelSpinComponent.get(wheel); // Read-only instance\\nconst mutableInstance = WheelSpinComponent.getMutable(wheel); // Mutable instance\\nWheelSpinComponent.deleteFrom(wheel); // Delete an instance"}
{"prompt": "Access a read-only and a mutable instance of WheelSpinComponent from an entity and then delete it.", "completion": "const readOnlyInstance = WheelSpinComponent.get(wheel); // Read-only instance\\nconst mutableInstance = WheelSpinComponent.getMutable(wheel); // Mutable instance\\nWheelSpinComponent.deleteFrom(wheel); // Delete an instance"}
{"prompt": "How do you define a flag component and use it in a system for querying?", "completion": "export const IsEnemyFlag = engine.defineComponent('isEnemyFlag', {});\\nexport function handleEnemies() {\\n  for (const [entity] of engine.getEntitiesWith(IsEnemyFlag)) {\\n    // Handle enemy logic\\n  }\\n}\\nengine.addSystem(handleEnemies);"}
{"prompt": "Define IsEnemyFlag component and create a system that queries entities with this flag.", "completion": "export const IsEnemyFlag = engine.defineComponent('isEnemyFlag', {});\\nexport function handleEnemies() {\\n  for (const [entity] of engine.getEntitiesWith(IsEnemyFlag)) {\\n    // Handle enemy logic\\n  }\\n}\\nengine.addSystem(handleEnemies);"}
{"prompt": "Declare a system that logs a message every tick and add it to the engine.", "completion": "function mySystem() {\\n  console.log('Performed on every tick. My system is running');\\n}\\nengine.addSystem(mySystem);"}
{"prompt": "Make entities spin.", "completion": "function moveSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(Transform)) {\\n    const transform = Transform.getMutable(entity);\\n    transform.position.z += 0.01 * dt;\\n  }\\n}\\nengine.addSystem(moveSystem);"}
{"prompt": "Create a system that applies consistent movement to entities with the Transform component.", "completion": "function moveSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(Transform)) {\\n    const transform = Transform.getMutable(entity);\\n    transform.position.z += 0.01 * dt;\\n  }\\n}\\nengine.addSystem(moveSystem);"}
{"prompt": "Implement and add a system to update and log the score component of an entity.", "completion": "export function main(){\\n  const game = engine.addEntity();\\n  ScoreComponent.create(game);\\n}\\nexport function UpdateScore() {\\n  const points = ScoreComponent.get(game).points;\\n  console.log(points);\\n}\\nengine.addSystem(UpdateScore);"}
{"prompt": "Make a system for updating and logging the score of a game entity.", "completion": "export function main(){\\n  const game = engine.addEntity();\\n  ScoreComponent.create(game);\\n}\\nexport function UpdateScore() {\\n  const points = ScoreComponent.get(game).points;\\n  console.log(points);\\n}\\nengine.addSystem(UpdateScore);"}
{"prompt": "Design a physics system that operates on entities with a specific component, using component queries for efficiency.", "completion": "export function PhysicsSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(HasPhysics)) {\\n    const transform = Transform.getMutable(entity);\\n    // Physics calculations here\\n  }\\n}\\nengine.addSystem(PhysicsSystem);"}
{"prompt": "Create a system that performs physics calculations on entities with a specific component.", "completion": "export function PhysicsSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(HasPhysics)) {\\n    const transform = Transform.getMutable(entity);\\n    // Physics calculations here\\n  }\\n}\\nengine.addSystem(PhysicsSystem);"}
{"prompt": "Implement a loop system that performs certain actions periodically based on a timer.", "completion": "let timer = 10;\\nfunction LoopSystem(dt: number) {\\n  timer -= dt;\\n  if (timer <= 0) {\\n    timer = 10; // Reset timer\\n    // DO SOMETHING periodically\\n  }\\n}\\nengine.addSystem(LoopSystem);"}
{"prompt": "Create a loop system that performs certain actions periodically based on a timer.", "completion": "let timer = 10;\\nfunction LoopSystem(dt: number) {\\n  timer -= dt;\\n  if (timer <= 0) {\\n    timer = 10; // Reset timer\\n    // DO SOMETHING periodically\\n  }\\n}\\nengine.addSystem(LoopSystem);"}
{"prompt": "Set the execution order of systems in Decentraland by specifying priorities.", "completion": "engine.addSystem(PhysicsSystem, 1);\\nengine.addSystem(BoundariesSystem, 5);"}
{"prompt": "Specify execution order for the PhysicsSystem and BoundariesSystem with specific priorities.", "completion": "engine.addSystem(PhysicsSystem, 1);\\nengine.addSystem(BoundariesSystem, 5);"}
{"prompt": "Remove a previously added system from the engine by its name.", "completion": "engine.addSystem(mySystem, 1, 'mySystemName');\\nengine.removeSystem('mySystemName');"}
{"prompt": "Delete a system from the engine using its name identifier.", "completion": "engine.addSystem(mySystem, 1, 'mySystemName');\\nengine.removeSystem('mySystemName');"}
{"prompt": "Explain the use of the Boolean type in schema fields.", "completion": "Schemas.Boolean is used to define fields that can hold a true or false value."}
{"prompt": "Describe how to use the Byte type within schema fields.", "completion": "Schemas.Byte is utilized for fields that store byte values, which are integers from 0 to 255."}
{"prompt": "Define the purpose of the Double type in schemas.", "completion": "Schemas.Double is used for fields that require double precision floating-point numbers."}
{"prompt": "Explain how the Float type is used in defining schema fields.", "completion": "Schemas.Float defines fields that hold single precision floating-point numbers."}
{"prompt": "Describe the use of the Int type in schemas.", "completion": "Schemas.Int is used for fields that store 32-bit integer values."}
{"prompt": "Explain when to use the Int64 type in schema fields.", "completion": "Schemas.Int64 is designed for fields that need to store 64-bit integer values."}
{"prompt": "Define the purpose of the Number type in schema definitions.", "completion": "Schemas.Number can be used for fields that require numeric values without specifying the precision."}
{"prompt": "Describe the role of the Short type within schema fields.", "completion": "Schemas.Short is intended for fields that store 16-bit integer values."}
{"prompt": "Explain the incorporation of the String type in schema fields.", "completion": "Schemas.String is used for fields that will hold text values."}
{"prompt": "Define the purpose of the Entity type in schemas.", "completion": "Schemas.Entity is used for fields that reference other entities."}
{"prompt": "Explain the structure and usage of the Vector3 type in schemas.", "completion": "Schemas.Vector3 is a complex type for fields that represent a 3D vector with x, y, and z numerical properties."}
{"prompt": "Describe the Quaternion type and its usage in schemas.", "completion": "Schemas.Quaternion is a complex type for fields representing rotations with x, y, z, and w numerical properties."}
{"prompt": "Explain the Color3 type and how it is applied in schemas.", "completion": "Schemas.Color3 is a complex type for fields that define colors using three numerical values: red, green, and blue."}
{"prompt": "Describe the differences between Color3 and Color4 types, and when to use each.", "completion": "Schemas.Color4 is a complex type similar to Color3 but includes an additional alpha (transparency) value, using four numerical values for red, green, blue, and alpha."}
{"prompt": "Define a new component with a schema in Decentraland.", "completion": "export const WheelSpinComponent = engine.defineComponent('wheelSpinComponent', {\\n  spinning: Schemas.Boolean,\\n  speed: Schemas.Float\\n});"}
{"prompt": "Create a component named WheelSpinComponent with spinning and speed properties.", "completion": "export const WheelSpinComponent = engine.defineComponent('wheelSpinComponent', {\\n  spinning: Schemas.Boolean,\\n  speed: Schemas.Float\\n});"}
{"prompt": "Create instances of a component for entities.", "completion": "const wheel = engine.addEntity();\\nWheelSpinComponent.create(wheel, {\\n  spinning: true,\\n  speed: 10\\n});\\nconst wheel2 = engine.addEntity();\\nWheelSpinComponent.create(wheel2, {\\n  spinning: false,\\n  speed: 0\\n});"}
{"prompt": "Create two entities with WheelSpinComponent instances, one spinning at speed 10 and the other not spinning.", "completion": "const wheel = engine.addEntity();\\nWheelSpinComponent.create(wheel, {\\n  spinning: true,\\n  speed: 10\\n});\\nconst wheel2 = engine.addEntity();\\nWheelSpinComponent.create(wheel2, {\\n  spinning: false,\\n  speed: 0\\n});"}
{"prompt": "Access and delete component instances from an entity.", "completion": "const readOnlyInstance = WheelSpinComponent.get(wheel); // Read-only instance\\nconst mutableInstance = WheelSpinComponent.getMutable(wheel); // Mutable instance\\nWheelSpinComponent.deleteFrom(wheel); // Delete an instance"}
{"prompt": "Access a read-only and a mutable instance of WheelSpinComponent from an entity and then delete it.", "completion": "const readOnlyInstance = WheelSpinComponent.get(wheel); // Read-only instance\\nconst mutableInstance = WheelSpinComponent.getMutable(wheel); // Mutable instance\\nWheelSpinComponent.deleteFrom(wheel); // Delete an instance"}
{"prompt": "Define a flag component and use it in a system for querying.", "completion": "export const IsEnemyFlag = engine.defineComponent('isEnemyFlag', {});\\nexport function handleEnemies() {\\n  for (const [entity] of engine.getEntitiesWith(IsEnemyFlag)) {\\n    // Handle enemy logic\\n  }\\n}\\nengine.addSystem(handleEnemies);"}
{"prompt": "Define IsEnemyFlag component and create a system that queries entities with this flag.", "completion": "export const IsEnemyFlag = engine.defineComponent('isEnemyFlag', {});\\nexport function handleEnemies() {\\n  for (const [entity] of engine.getEntitiesWith(IsEnemyFlag)) {\\n    // Handle enemy logic\\n  }\\n}\\nengine.addSystem(handleEnemies);"}
{"prompt": "How do you utilize enums within component schemas in Decentraland?", "completion": "enum Color { Red = 'red', Green = 'green', Pink = 'pink' }\\nconst ColorComponent = engine.defineComponent('ColorComponent', { \\n  color: Schemas.EnumString<Color>(Color, Color.Red)\\n});\\nenum CurveType { LINEAR, EASEIN, EASEOUT }\\nconst CurveComponent = engine.defineComponent('CurveComponent', { \\n  curve: Schemas.EnumNumber<CurveType>(CurveType, CurveType.LINEAR)\\n});"}
{"prompt": "Define components with enum properties for color and curve types.", "completion": "enum Color { Red = 'red', Green = 'green', Pink = 'pink' }\\nconst ColorComponent = engine.defineComponent('ColorComponent', { \\n  color: Schemas.EnumString<Color>(Color, Color.Red)\\n});\\nenum CurveType { LINEAR, EASEIN, EASEOUT }\\nconst CurveComponent = engine.defineComponent('CurveComponent', { \\n  curve: Schemas.EnumNumber<CurveType>(CurveType, CurveType.LINEAR)\\n});"}
{"prompt": "How do you create a system that modifies the rotation of entities with a specific component based on its properties?", "completion": "export function spinSystem(dt: number) {\\n  for (const [entity, wheelSpin] of engine.getEntitiesWith(WheelSpinComponent)) {\\n    if(wheelSpin.spinning) {\\n      const transform = Transform.getMutable(entity);\\n      transform.rotation = Quaternion.multiply(transform.rotation, Quaternion.fromAngleAxis(dt * wheelSpin.speed, Vector3.Up()));\\n    }\\n  }\\n}\\nengine.addSystem(spinSystem);"}
{"prompt": "Implement a system that rotates entities with the WheelSpinComponent based on their spinning state and speed.", "completion": "export function spinSystem(dt: number) {\\n  for (const [entity, wheelSpin] of engine.getEntitiesWith(WheelSpinComponent)) {\\n    if(wheelSpin.spinning) {\\n      const transform = Transform.getMutable(entity);\\n      transform.rotation = Quaternion.multiply(transform.rotation, Quaternion.fromAngleAxis(dt * wheelSpin.speed, Vector3.Up()));\\n    }\\n  }\\n}\\nengine.addSystem(spinSystem);"}
{"prompt": "How do you iterate over entities that have a Transform component?", "completion": "for (const [entity] of engine.getEntitiesWith(Transform)) {\\n  // Operations on each entity with a Transform component\\n}"}
{"prompt": "Iterate over entities with a Transform component and perform operations.", "completion": "for (const [entity] of engine.getEntitiesWith(Transform)) {\\n  // Operations on each entity with a Transform component\\n}"}
{"prompt": "How do you specify multiple required components in a query for iterating over entities?", "completion": "for (const [entity] of engine.getEntitiesWith(Transform, Physics, NextPosition)) {\\n  // Operations on entities with Transform, Physics, and NextPosition components\\n}"}
{"prompt": "Query entities that have Transform, Physics, and NextPosition components and perform operations.", "completion": "for (const [entity] of engine.getEntitiesWith(Transform, Physics, NextPosition)) {\\n  // Operations on entities with Transform, Physics, and NextPosition components\\n}"}
{"prompt": "How do you define a system that queries entities with specific components and updates their position based on velocity?", "completion": "function PhysicsSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(Transform, Physics)) {\\n    const transform = Transform.getMutable(entity);\\n    const vel = Physics.get(entity).velocity;\\n    transform.position.x += vel.x * dt;\\n    transform.position.y += vel.y * dt;\\n    transform.position.z += vel.z * dt;\\n  }\\n}\\nengine.addSystem(PhysicsSystem);"}
{"prompt": "Define a PhysicsSystem that updates entity positions based on their velocity.", "completion": "function PhysicsSystem(dt: number) {\\n  for (const [entity] of engine.getEntitiesWith(Transform, Physics)) {\\n    const transform = Transform.getMutable(entity);\\n    const vel = Physics.get(entity).velocity;\\n    transform.position.x += vel.x * dt;\\n    transform.position.y += vel.y * dt;\\n    transform.position.z += vel.z * dt;\\n  }\\n}\\nengine.addSystem(PhysicsSystem);"}
{"prompt": "How do you access read-only and mutable versions of components within a query?", "completion": "for (const [entity] of engine.getEntitiesWith(Transform)) {\\n  const transformReadOnly = Transform.get(entity); // Read-only version\\n  const transformMutable = Transform.getMutable(entity); // Mutable version\\n}"}
{"prompt": "Access both read-only and mutable versions of the Transform component for entities.", "completion": "for (const [entity] of engine.getEntitiesWith(Transform)) {\\n  const transformReadOnly = Transform.get(entity); // Read-only version\\n  const transformMutable = Transform.getMutable(entity); // Mutable version\\n}"}
{"prompt": "How do you perform advanced querying with direct references to components in a Decentraland scene?", "completion": "for (const [entity, customComponent1] of engine.getEntitiesWith(MyCustomComponent1, MyCustomComponent2)) {\\n  // Directly accessing customComponent1 for each entity\\n}\\nfor (const [entity, customComponent1, customComponent2] of engine.getEntitiesWith(MyCustomComponent1, MyCustomComponent2)) {\\n  // Directly accessing customComponent1 and customComponent2 for each entity\\n}"}
{"prompt": "Query entities with custom components and access these components directly in the loop.", "completion": "for (const [entity, customComponent1] of engine.getEntitiesWith(MyCustomComponent1, MyCustomComponent2)) {\\n  // Directly accessing customComponent1 for each entity\\n}\\nfor (const [entity, customComponent1, customComponent2] of engine.getEntitiesWith(MyCustomComponent1, MyCustomComponent2)) {\\n  // Directly accessing customComponent1 and customComponent2 for each entity\\n}"}
{"prompt": "Create a new entity and set its position, rotation, and scale using the Transform component.", "completion": "const entity = engine.addEntity();\\nTransform.create(entity, {\\n  position: Vector3.create(5, 1, 5),\\n  scale: Vector3.create(1, 1, 1),\\n  rotation: Quaternion.Zero(),\\n});"}
{"prompt": "Update an entity's position, rotation, and scale over time.", "completion": "const mutableTransform = Transform.getMutable(entity);\\nmutableTransform.position = Vector3.create(2, 1, 4);\\nmutableTransform.rotation = Quaternion.fromEulerDegrees(0, 90, 0);\\nmutableTransform.scale = Vector3.create(2, 2, 2);"}
{"prompt": "Attach a Billboard component to an entity to make it face the player.", "completion": "const billboardEntity = engine.addEntity();\\nBillboard.create(billboardEntity, { billboardMode: BillboardMode.BM_Y });"}
{"prompt": "Write a function that makes an entity turn towards a specific position.", "completion": "export function turnTowards(entity: Entity, targetPosition: ReadOnlyVector3) {\\n  const transform = Transform.getMutable(entity);\\n  const direction = Vector3.subtract(targetPosition, transform.position);\\n  const normalizedDirection = Vector3.normalize(direction);\\n  transform.rotation = Quaternion.lookRotation(normalizedDirection);\\n}"}
{"prompt": "Attach an entity to the player avatar using the Transform component.", "completion": "let attachedEntity = engine.addEntity();\\nMeshRenderer.setCylinder(attachedEntity);\\nTransform.create(attachedEntity, {\\n  scale: Vector3.create(0.2, 0.2, 0.2),\\n  position: Vector3.create(0, 0.4, 0),\\n  parent: engine.PlayerEntity, // or engine.CameraEntity for camera attachment\\n});"}
{"prompt": "Attach an entity to a specific bone of the player avatar.", "completion": "AvatarAttach.create(attachedEntity, {\\n  anchorPointId: AvatarAnchorPointType.AAPT_RIGHT_HAND,\\n  avatarId: '0xPlayerAddress', // Optional, if attaching to another player\\n});"}
{"prompt": "Create a cube entity with a Transform and MeshRenderer component.", "completion": "const myCube = engine.addEntity();\\nTransform.create(myCube, { position: Vector3.create(8, 1, 8) });\\nMeshRenderer.setBox(myCube);"}
{"prompt": "Create a cone entity by setting the top radius of a cylinder to 0.", "completion": "const myCone = engine.addEntity();\\nTransform.create(myCone, { position: Vector3.create(8, 1, 8) });\\nMeshRenderer.setCylinder(myCone, 0, 1); // radiusTop, radiusBottom"}
{"prompt": "Change an entity's shape from a cube to a sphere.", "completion": "MeshRenderer.setSphere(myCube);"}
{"prompt": "Make an entity invisible by attaching a VisibilityComponent.", "completion": "const myEntity = engine.addEntity();\\nTransform.create(myEntity, { position: Vector3.create(4, 0, 4) });\\nMeshRenderer.setBox(myEntity);\\nVisibilityComponent.create(myEntity, { visible: false });"}
{"prompt": "Check the loading state of a 3D model in an entity.", "completion": "export function main() {\\n  const meshEntity = engine.addEntity();\\n  GltfContainer.create(meshEntity, { src: 'models/Monster.glb' });\\n  engine.addSystem((deltaTime) => {\\n    const loadingState = GltfContainerLoadingState.getOrNull(meshEntity);\\n    if (!loadingState) return;\\n    switch (loadingState.currentState) {\\n      case LoadingState.LOADING: console.log('mesh is LOADING'); break;\\n      case LoadingState.FINISHED: console.log('mesh is FINISHED'); break;\\n      case LoadingState.FINISHED_WITH_ERROR: console.log('mesh is FINISHED BUT MAY HAVE PROBLEMS'); break;\\n      case LoadingState.UNKNOWN: console.log('mesh is in an UNKNOWN STATE'); break;\\n    }\\n  });\\n}"}
{"prompt": "Use advanced syntax for creating a MeshRenderer component with specific mesh options.", "completion": "MeshRenderer.setBox(myCube, { mesh: { $case: 'box', box: { uvs: [] } } });\\nMeshRenderer.setPlane(myCube, { mesh: { $case: 'plane', plane: { uvs: [] } } });\\nMeshRenderer.setSphere(myCube, { mesh: { $case: 'sphere', sphere: {} } });\\nMeshRenderer.setCylinder(myCube, { mesh: { $case: 'cylinder', cylinder: {} } });"}
{"prompt": "Create a cube", "completion": "const myCube = engine.addEntity();\\nTransform.create(myCube, { position: Vector3.create(8, 1, 8) });\\nMeshRenderer.setBox(myCube);"}
{"prompt": "Create a cone", "completion": "const myCone = engine.addEntity();\\nTransform.create(myCone, { position: Vector3.create(8, 1, 8) });\\nMeshRenderer.setCylinder(myCone, 0, 1); // radiusTop, radiusBottom"}
{"prompt": "Change shape to a sphere.", "completion": "MeshRenderer.setSphere(myCube);"}
{"prompt": "Make an entity invisible.", "completion": "const myEntity = engine.addEntity();\\nTransform.create(myEntity, { position: Vector3.create(4, 0, 4) });\\nMeshRenderer.setBox(myEntity);\\nVisibilityComponent.create(myEntity, { visible: false });"}
{"prompt": "Check the loading state of a 3D model", "completion": "export function main() {\\n  const meshEntity = engine.addEntity();\\n  GltfContainer.create(meshEntity, { src: 'models/Monster.glb' });\\n  engine.addSystem((deltaTime) => {\\n    const loadingState = GltfContainerLoadingState.getOrNull(meshEntity);\\n    if (!loadingState) return;\\n    switch (loadingState.currentState) {\\n      case LoadingState.LOADING: console.log('mesh is LOADING'); break;\\n      case LoadingState.FINISHED: console.log('mesh is FINISHED'); break;\\n      case LoadingState.FINISHED_WITH_ERROR: console.log('mesh is FINISHED BUT MAY HAVE PROBLEMS'); break;\\n      case LoadingState.UNKNOWN: console.log('mesh is in an UNKNOWN STATE'); break;\\n    }\\n  });\\n}"}
{"prompt": "Create an entity with a PBR material including albedo color, metallic, and roughness properties.", "completion": "const meshEntity = engine.addEntity();\\nTransform.create(meshEntity, { position: Vector3.create(4, 1, 4) });\\nMeshRenderer.setBox(meshEntity);\\nMaterial.setPbrMaterial(meshEntity, {\\n  albedoColor: Color4.Red(),\\n  metallic: 0.8,\\n  roughness: 0.1,\\n});"}
{"prompt": "Change the color of an entity's PBR material to blue.", "completion": "Material.setPbrMaterial(meshEntity, { albedoColor: Color4.Blue() });"}
{"prompt": "Create a basic material with a texture from an internal path for an entity.", "completion": "Material.setBasicMaterial(meshEntity, {\\n  texture: Material.Texture.Common({ src: 'materials/wood.png' }),\\n});"}
{"prompt": "Apply a texture from an external URL to a basic material for an entity.", "completion": "Material.setBasicMaterial(meshEntity, {\\n  texture: Material.Texture.Common({\\n    src: 'https://example.com/texture.png',\\n  }),\\n});"}
{"prompt": "Use multi-layered textures in a PBR material for an entity.", "completion": "Material.setPbrMaterial(meshEntity, {\\n  texture: Material.Texture.Common({ src: 'materials/wood.png' }),\\n  bumpTexture: Material.Texture.Common({ src: 'materials/woodBump.png' }),\\n});"}
{"prompt": "Create a material with texture wrapping and scaling using a plane mesh.", "completion": "MeshRenderer.setPlane(meshEntity, [\\n  0, 0, 1, 0, 1, 1, 0, 1, // UV coordinates for plane\\n]);\\nMaterial.setPbrMaterial(meshEntity, {\\n  texture: Material.Texture.Common({\\n    src: 'materials/wood.png',\\n    wrapMode: TextureWrapMode.TWM_REPEAT,\\n  }),\\n});"}
{"prompt": "Display an avatar portrait as a texture on an entity.", "completion": "Material.setPbrMaterial(meshEntity, {\\n  texture: Material.Texture.Avatar({ userId: '0x517....' }),\\n});"}
{"prompt": "Create a transparent material with a specified color and transparency level.", "completion": "let transparentRed = Color4.create(1, 0, 0, 0.5);\\nMaterial.setPbrMaterial(meshEntity, { albedoColor: transparentRed });"}
{"prompt": "Implement transparency modes for textures with alpha channels in a PBR material.", "completion": "Material.setPbrMaterial(meshEntity, {\\n  texture: Material.Texture.Common({ src: 'images/myTexture.png' }),\\n  transparencyMode: MaterialTransparencyMode.MTM_ALPHA_TEST,\\n  alphaTest: 1,\\n});"}
{"prompt": "Create solid and transparent red colors using Color3 and Color4.", "completion": "const red3 = Color3.create(1, 0, 0);\\nconst red4 = Color4.create(1, 0, 0, 1);"}
{"prompt": "Generate a random color and create a color from a hex string.", "completion": "const randomColor = Color3.Random();\\nconst hexRed = Color3.fromHexString('FD350A');"}
{"prompt": "Use a predefined blue color in Decentraland.", "completion": "const blue = Color3.Blue();"}
{"prompt": "Apply a red text color to a TextShape component.", "completion": "const myEntity = engine.addEntity();\\nTransform.create(myEntity, { position: Vector3.create(4, 1, 4) });\\nTextShape.create(myEntity, { text: 'this text is RED', textColor: Color4.create(1, 0, 0, 1) });"}
{"prompt": "Create a color with 50% transparency using Color4.", "completion": "const halfTransparent = Color4.create(1, 1, 1, 0.5);"}
{"prompt": "Interpolate between red and yellow to get orange.", "completion": "const orange = Color3.lerp(Color3.Red(), Color3.Yellow(), 0.3);"}
{"prompt": "Implement a system that gradually changes color between red and yellow.", "completion": "var pulseState = 0;\\nconst color1 = Color4.Red();\\nconst color2 = Color4.Yellow();\\nexport function PulseSystem(dt) {\\n  pulseState += dt;\\n  const entitiesWithMaterial = engine.getEntitiesWith(Material);\\n  for (const [entity] of entitiesWithMaterial) {\\n    const material = Material.getMutable(entity);\\n    material.albedoColor = Color4.lerp(color1, color2, Math.sin(pulseState));\\n  }\\n}\\nengine.addSystem(PulseSystem);"}
{"prompt": "Create an entity with an AudioSource component to loop and play a sound.", "completion": "const sourceEntity = engine.addEntity();\\nAudioSource.create(sourceEntity, {\\n  audioClipUrl: 'sounds/sound-effect.mp3',\\n  loop: true,\\n  playing: true,\\n});"}
{"prompt": "Write a function to start playing a sound on an entity.", "completion": "function playSound(entity: Entity) {\\n  const audioSource = AudioSource.getMutable(entity);\\n  audioSource.playing = true; // Start playing the sound\\n}"}
{"prompt": "Write a function to stop a sound on an entity.", "completion": "function stopSound(entity: Entity) {\\n  const audioSource = AudioSource.getMutable(entity);\\n  audioSource.playing = false; // Stop playing the sound\\n}"}
{"prompt": "How do you adjust the volume of an AudioSource on an entity?", "completion": "function setVolume(entity: Entity, volume: number) {\\n  const audioSource = AudioSource.getMutable(entity);\\n  audioSource.volume = volume; // Set volume, range from 0 to 1\\n}"}
{"prompt": "Add a 3D model of a shark with animations to your scene.", "completion": "const shark = engine.addEntity();\\nGltfContainer.create(shark, { src: 'models/shark.glb' });"}
{"prompt": "How do you add an Animator component to handle multiple animations for an entity?", "completion": "Animator.create(shark, {\\n  states: [\\n    { clip: 'swim', playing: true, loop: true },\\n    { clip: 'bite', playing: false, loop: false }\\n  ],\\n});"}
{"prompt": "Modify an animation clip's properties like looping and playing status.", "completion": "const swimAnim = Animator.getClip(shark, 'swim');\\nswimAnim.looping = false;\\nswimAnim.playing = true;"}
{"prompt": "Play a specific animation while stopping others on an entity.", "completion": "Animator.playSingleAnimation(shark, 'swim', true);"}
{"prompt": "Stop all animations on an entity.", "completion": "Animator.stopAllAnimations(shark);"}
{"prompt": "Adjust the speed of an animation clip.", "completion": "const biteAnim = Animator.getClip(shark, 'bite');\\nbiteAnim.speed = 2;"}
{"prompt": "Change the weight of an animation to blend it with others.", "completion": "const swimAnimWeighted = Animator.getClip(shark, 'swim');\\nswimAnimWeighted.weight = 0.5;"}
{"prompt": "Create a TextShape component with 'Hello World' text and add it to an entity.", "completion": "const sign = engine.addEntity(true);\\nTransform.create(sign, {\\n  position: Vector3.create(8, 1, 8),\\n});\\nTextShape.create(sign, {\\n  text: 'Hello World',\\n});"}
{"prompt": "Change the text value of a TextShape component to a new string.", "completion": "const mutableText = TextShape.getMutable(sign);\\nmutableText.text = 'new string';"}
{"prompt": "Style text with basic properties like color, font size, and font type.", "completion": "TextShape.create(sign, {\\n  text: 'Hello World',\\n  textColor: Color4.create(1, 0, 0, 1),\\n  fontSize: 5,\\n  font: Font.F_SANS_SERIF,\\n});"}
{"prompt": "Set text alignment and padding for a TextShape component.", "completion": "TextShape.create(sign, {\\n  text: 'Aligned Text',\\n  textAlign: TextAlignMode.CENTER,\\n  width: 2,\\n  height: 1,\\n  paddingTop: 0.1,\\n  paddingRight: 0.1,\\n  paddingBottom: 0.1,\\n  paddingLeft: 0.1,\\n});"}
{"prompt": "Add shadow properties to text.", "completion": "TextShape.create(sign, {\\n  text: 'Text with shadow',\\n  shadowColor: Color3.create(1, 0, 0),\\n  shadowOffsetY: 1,\\n  shadowOffsetX: -1,\\n  shadowBlur: 2,\\n});"}
{"prompt": "Create text with an outline effect.", "completion": "TextShape.create(sign, {\\n  text: 'Text with outline',\\n  outlineWidth: 1,\\n  outlineColor: Color3.create(0, 1, 0),\\n});"}
{"prompt": "Configure a TextShape component for multiline text.", "completion": "TextShape.create(sign, {\\n  text: 'This is one line. \\nThis is another line',\\n  lineCount: 2,\\n  lineSpacing: \"30px\",\\n});"}
{"prompt": "Move an entity between two points using a linear tween.", "completion": "const myEntity = engine.addEntity();\\nTransform.create(myEntity, {\\n  position: Vector3.create(4, 1, 4),\\n});\\nMeshRenderer.setBox(myEntity);\\nTween.create(myEntity, {\\n  mode: Tween.Mode.Move({\\n    start: Vector3.create(1, 1, 1),\\n    end: Vector3.create(8, 1, 8),\\n  }),\\n  duration: 2000,\\n  easingFunction: EasingFunction.EF_LINEAR,\\n});"}
{"prompt": "Rotate an entity between two orientations over time.", "completion": "Tween.create(myEntity, {\\n  mode: Tween.Mode.Rotate({\\n    start: Quaternion.fromEulerDegrees(0, 0, 0),\\n    end: Quaternion.fromEulerDegrees(0, 170, 0),\\n  }),\\n  duration: 700,\\n  easingFunction: EasingFunction.EF_LINEAR,\\n});"}
{"prompt": "Implement rotation of an entity around a pivot point.", "completion": "const pivotEntity = engine.addEntity();\\nTransform.create(pivotEntity, {\\n  position: Vector3.create(4, 1, 4),\\n});\\nconst childEntity = engine.addEntity();\\nTransform.create(childEntity, {\\n  position: Vector3.create(1, 0, 0),\\n  parent: pivotEntity,\\n});\\nMeshRenderer.setBox(childEntity);\\nTween.create(pivotEntity, {\\n  mode: Tween.Mode.Rotate({\\n    start: Quaternion.fromEulerDegrees(0, 0, 0),\\n    end: Quaternion.fromEulerDegrees(0, 170, 0),\\n  }),\\n  duration: 700,\\n  easingFunction: EasingFunction.EF_LINEAR,\\n});"}
{"prompt": "Scale an entity between two sizes with a linear tween.", "completion": "Tween.create(myEntity, {\\n  mode: Tween.Mode.Scale({\\n    start: Vector3.create(1, 1, 1),\\n    end: Vector3.create(4, 4, 4),\\n  }),\\n  duration: 2000,\\n  easingFunction: EasingFunction.EF_LINEAR,\\n});"}
{"prompt": "Create a non-linear scale tween with an ease out bounce effect.", "completion": "Tween.create(myEntity, {\\n  mode: Tween.Mode.Scale({\\n    start: Vector3.create(1, 1, 1),\\n    end: Vector3.create(4, 4, 4),\\n  }),\\n  duration: 2000,\\n  easingFunction: EasingFunction.EF_EASEOUTBOUNCE,\\n  playing: true,\\n});"}
{"prompt": "Set up a tween sequence to move an entity back and forth.", "completion": "Tween.create(myEntity, {\\n  mode: Tween.Mode.Move({\\n    start: Vector3.create(1, 1, 1),\\n    end: Vector3.create(8, 1, 8),\\n  }),\\n  duration: 2000,\\n  easingFunction: EasingFunction.EF_LINEAR,\\n});\\nTweenSequence.create(myEntity, { sequence: [], loop: TweenLoop.TL_YOYO });"}
{"prompt": "Pause and resume a tween with a button press.", "completion": "pointerEventsSystem.onPointerDown({\\n  entity: button,\\n  opts: { button: InputAction.IA_POINTER, hoverText: 'pause' },\\n}, () => {\\n  let tweenData = Tween.getMutable(myEntity);\\n  tweenData.playing = !tweenData.playing;\\n});"}
{"prompt": "Describe the effect of the EF_EASEBACK easing function.", "completion": "The EF_EASEBACK easing function creates a motion that goes back slightly at the start or end of the animation, creating a 'pull back' effect before animating."}
{"prompt": "Explain the EF_EASEBOUNCE easing function.", "completion": "The EF_EASEBOUNCE easing function simulates a bouncing motion at the end of the animation, as if the animated object is bouncing against a surface."}
{"prompt": "What does the EF_EASECIRC easing function do?", "completion": "The EF_EASECIRC easing function creates a motion that starts slow and then accelerates in a circular manner, decelerating at the end."}
{"prompt": "Describe the animation effect created by the EF_EASECUBIC easing function.", "completion": "The EF_EASECUBIC easing function produces an animation that starts slowly, accelerates sharply, and then decelerates smoothly towards the end."}
{"prompt": "Explain the purpose of the EF_EASEELASTIC easing function.", "completion": "The EF_EASEELASTIC easing function generates an animation that stretches and bounces, similar to an elastic band effect, before settling into the final state."}
{"prompt": "How does the EF_EASEEXPO easing function affect an animation?", "completion": "The EF_EASEEXPO easing function creates a dramatic acceleration or deceleration, giving the effect of an exponential curve, making animations start or end very quickly."}
{"prompt": "What effect does the EF_EASEINBACK easing function have on animations?", "completion": "The EF_EASEINBACK easing function causes an animation to start by moving back slightly, creating a 'wind-up' effect before accelerating forward."}
{"prompt": "Describe the EF_EASEINBOUNCE function's impact on animation.", "completion": "The EF_EASEINBOUNCE easing function simulates an animation starting with a bounce effect, as if the object bounces into place from the start."}
{"prompt": "How is the EF_EASEINCIRC function used in animations?", "completion": "The EF_EASEINCIRC easing function creates a smooth, circular acceleration from the start, making the motion start slow and then accelerate."}
{"prompt": "Explain the animation behavior of the EF_EASEINCUBIC function.", "completion": "The EF_EASEINCUBIC easing function produces a cubic acceleration, starting slow and then increasing speed rapidly."}
{"prompt": "What does the EF_EASEINELASTIC easing function simulate?", "completion": "The EF_EASEINELASTIC easing function simulates an elastic start to an animation, where the motion stretches back before moving forward."}
{"prompt": "Describe the effect of the EF_EASEINEXPO easing function on animations.", "completion": "The EF_EASEINEXPO easing function creates an animation that starts slowly and then accelerates exponentially, creating a sharp increase in speed."}
{"prompt": "How does the EF_EASEINQUAD easing function modify animation?", "completion": "The EF_EASEINQUAD easing function applies a quadratic acceleration at the start of the animation, making the motion start slow and then gradually speed up."}
{"prompt": "Explain the effect of the EF_EASEINQUART on animations.", "completion": "The EF_EASEINQUART easing function produces a quartic acceleration at the beginning of the animation, starting very slow and then speeding up more sharply."}
{"prompt": "Describe the EF_EASEINQUINT easing function's impact.", "completion": "The EF_EASEINQUINT easing function applies a quintic acceleration at the start, making animations begin very slowly before accelerating much faster."}
{"prompt": "What does the EF_EASEINSINE easing function do?", "completion": "The EF_EASEINSINE easing function creates a smooth acceleration at the beginning of an animation based on a sine wave, offering a gentle start."}
{"prompt": "How does the EF_EASEOUTBACK easing function affect animations?", "completion": "The EF_EASEOUTBACK easing function causes animations to overshoot their end slightly before settling into the final position, creating a 'snap back' effect."}
{"prompt": "Describe the animation effect created by the EF_EASEOUTBOUNCE function.", "completion": "The EF_EASEOUTBOUNCE easing function simulates a bouncing motion at the end, as if the object is bouncing to a stop."}
{"prompt": "Explain the use of the EF_EASEOUTCIRC function in animations.", "completion": "The EF_EASEOUTCIRC easing function creates a motion that decelerates in a circular manner, slowing down smoothly towards the end."}
{"prompt": "What effect does the EF_EASEOUTCUBIC function have?", "completion": "The EF_EASEOUTCUBIC easing function produces a smooth deceleration towards the end of an animation, starting fast and then slowing down gradually."}
{"prompt": "Describe the EF_EASEOUTELASTIC function's animation effect.", "completion": "The EF_EASEOUTELASTIC easing function generates an animation that ends with an elastic effect, stretching and bouncing before settling."}
{"prompt": "How does the EF_EASEOUTEXPO function modify animations?", "completion": "The EF_EASEOUTEXPO easing function applies an exponential deceleration, making animations slow down very quickly towards the end."}
{"prompt": "Explain the behavior of the EF_EASEOUTQUAD easing function.", "completion": "The EF_EASEOUTQUAD easing function applies a quadratic deceleration, slowing down the animation smoothly towards the end."}
{"prompt": "Describe the impact of the EF_EASEOUTQUART on animation.", "completion": "The EF_EASEOUTQUART easing function produces a quartic deceleration, starting fast and then slowing down significantly towards the end."}
{"prompt": "What does the EF_EASEOUTQUINT function do?", "completion": "The EF_EASEOUTQUINT easing function creates a quintic deceleration, slowing down very sharply towards the end of the animation."}
{"prompt": "How is the EF_EASEOUTSINE easing function used?", "completion": "The EF_EASEOUTSINE easing function creates a smooth deceleration based on a sine wave, offering a gentle ending to animations."}
{"prompt": "Describe the EF_EASEQUAD function's effect on animations.", "completion": "The EF_EASEQUAD easing function applies a quadratic curve to animations, offering a balanced acceleration and deceleration."}
{"prompt": "Explain the effect of the EF_EASEQUART easing function.", "completion": "The EF_EASEQUART easing function applies a quartic curve to animations, providing a pronounced acceleration or deceleration."}
{"prompt": "What impact does the EF_EASEQUINT have on animation?", "completion": "The EF_EASEQUINT easing function offers a quintic curve to animations, creating a very sharp acceleration or deceleration."}
{"prompt": "How does the EF_EASESINE function affect animations?", "completion": "The EF_EASESINE easing function creates a smooth and natural acceleration or deceleration based on a sine wave."}
{"prompt": "What is the characteristic of the EF_LINEAR easing function?", "completion": "The EF_LINEAR easing function applies a constant rate of change, creating a steady and uniform motion throughout the animation."}
{"prompt": "Create a Vector3 object with specific x, y, and z values.", "completion": "let myVector = Vector3.create(3, 1, 5);"}
{"prompt": "Alternative method to instantiate a Vector3 object.", "completion": "let myOtherVector: Vector3 = { x: 8, y: 1, z: 8 };"}
{"prompt": "Normalize a vector to have a magnitude of 1.", "completion": "let normalizedVector = Vector3.normalize(myVector);"}
{"prompt": "Calculate the distance between two Vector3 objects.", "completion": "let distance = Vector3.distance(myVector, myOtherVector);"}
{"prompt": "Find the midpoint between two Vector3 objects.", "completion": "let midPoint = Vector3.lerp(myVector, myOtherVector, 0.5);"}
{"prompt": "Access shortcut direction vectors in Vector3.", "completion": "let up = Vector3.Up();\\nlet down = Vector3.Down();\\nlet left = Vector3.Left();\\nlet right = Vector3.Right();\\nlet forward = Vector3.Forward();\\nlet backward = Vector3.Backward();"}
{"prompt": "Create a Quaternion object with x, y, z, and w components.", "completion": "let myQuaternion = Quaternion.create(0, 0, 0, 1);"}
{"prompt": "Convert Euler angles to a Quaternion.", "completion": "let fromEuler = Quaternion.fromEulerDegrees(90, 0, 0);"}
{"prompt": "Convert a Quaternion to Euler angles.", "completion": "let toEuler = Quaternion.toEulerAngles(myQuaternion);"}
{"prompt": "Generate a random scalar value within a specified range.", "completion": "let random = Scalar.randomRange(1, 100);"}
{"prompt": "Find the midpoint of two scalar values.", "completion": "let midPointScalar = Scalar.lerp(1, 10, 0.5);"}
{"prompt": "Clamp a scalar value to be within a specified range.", "completion": "let clampedValue = Scalar.clamp(150, 0, 100);"}
{"prompt": "Create an entity with a box collider component.", "completion": "const myCollider = engine.addEntity();\\nMeshRenderer.setBox(myCollider);\\nMeshCollider.setBox(myCollider);"}
{"prompt": "Assign a GLTF shape to an entity with specific collision layers for invisible and visible meshes.", "completion": "GltfContainer.create(myEntity, {\\n  src: '/models/myModel.gltf',\\n  invisibleMeshesCollisionMask: ColliderLayer.CL_PHYSICS,\\n  visibleMeshesCollisionMask: ColliderLayer.CL_POINTER,\\n});"}
{"prompt": "Create a MeshCollider component that only responds to player physics.", "completion": "MeshCollider.setBox(myEntity, ColliderLayer.CL_PHYSICS);"}
{"prompt": "Use multiple collision layers on a MeshCollider component.", "completion": "MeshCollider.setBox(\\n  myEntity,\\n  ColliderLayer.CL_CUSTOM1 |\\n    ColliderLayer.CL_CUSTOM3 |\\n    ColliderLayer.CL_PHYSICS |\\n    ColliderLayer.CL_POINTER\\n);"}
{"prompt": "Set the default behavior for GLTFContainer's collision layers.", "completion": "GltfContainer.create(myEntity, {\\n  src: '/models/myModel.gltf',\\n});"}
{"prompt": "Configure a GLTFContainer to use visible geometry for pointer events.", "completion": "GltfContainer.create(myEntity2, {\\n  src: '/models/myModel.gltf',\\n  invisibleMeshesCollisionMask: ColliderLayer.CL_PHYSICS,\\n  visibleMeshesCollisionMask: ColliderLayer.CL_POINTER,\\n});"}
{"prompt": "Configure a GLTFContainer to use visible geometry for both physics and pointer events.", "completion": "GltfContainer.create(myEntity, {\\n  src: '/models/myModel.gltf',\\n  invisibleMeshesCollisionMask: ColliderLayer.CL_NONE,\\n  visibleMeshesCollisionMask: ColliderLayer.CL_POINTER | ColliderLayer.CL_PHYSICS,\\n});"}
{"prompt": "Set a GLTFContainer to not respond to any collisions.", "completion": "GltfContainer.create(myEntity, {\\n  src: '/models/myModel.gltf',\\n  invisibleMeshesCollisionMask: ColliderLayer.CL_NONE,\\n});"}
{"prompt": "Create an entity with an AudioStream component to play a stream from a URL.", "completion": "const streamEntity = engine.addEntity()\\n\\nAudioStream.create(streamEntity, {\\n  url: 'https://icecast.ravepartyradio.org/ravepartyradio-192.mp3',\\n  playing: true,\\n  volume: 0.8,\\n})"}
{"prompt": "Create a video screen entity with a plane shape and assign a VideoPlayer component for local video playback.", "completion": "const screen = engine.addEntity();\\nMeshRenderer.setPlane(screen);\\nTransform.create(screen, { position: { x: 4, y: 1, z: 4 } });\\n\\nVideoPlayer.create(screen, {\\n  src: 'videos/myVideo.mp3',\\n  playing: true,\\n});"}
{"prompt": "Assign a VideoPlayer component to play an external video stream on a screen entity.", "completion": "VideoPlayer.create(screen, {\\n  src: 'https://player.vimeo.com/external/552481870.m3u8?s=c312c8533f97e808fccc92b0510b085c8122a875',\\n  playing: true,\\n});"}
{"prompt": "Create a VideoTexture from a VideoPlayer and use it in a PBR material for a video screen.", "completion": "const videoTexture = Material.Texture.Video({ videoPlayerEntity: screen });\\nMaterial.setPbrMaterial(screen, {\\n  texture: videoTexture,\\n  roughness: 1.0,\\n  specularIntensity: 0,\\n  metallic: 0,\\n});"}
{"prompt": "Configure a screen's material to emit light based on the video texture for a glowing effect.", "completion": "Material.setPbrMaterial(screen, {\\n  texture: videoTexture,\\n  emissiveTexture: videoTexture,\\n  emissiveIntensity: 0.6,\\n  emissiveColor: Color3.White(),\\n});"}
{"prompt": "Toggle play/pause on a video screen using a pointer event.", "completion": "pointerEventsSystem.onPointerDown(\\n  {\\n    entity: screen,\\n    opts: { button: InputAction.IA_POINTER, hoverText: 'Play/Pause' },\\n  },\\n  function () {\\n    const videoPlayer = VideoPlayer.getMutable(screen);\\n    videoPlayer.playing = !videoPlayer.playing;\\n  }\\n);"}
{"prompt": "Stop video playback and reset the video position with a pointer event on a screen entity.", "completion": "pointerEventsSystem.onPointerDown(\\n  {\\n    entity: screen,\\n    opts: { button: InputAction.IA_POINTER, hoverText: 'STOP' },\\n  },\\n  function () {\\n    const videoPlayer = VideoPlayer.getMutable(screen);\\n    videoPlayer.playing = false;\\n    videoPlayer.position = 0;\\n  }\\n);"}
{"prompt": "Play a video from Decentraland Cast on a screen entity, selecting the first active video stream available.", "completion": "const { streams } = await getActiveVideoStreams({});\\nif (streams.length > 0) {\\n  const stream = streams[0];\\n  VideoPlayer.createOrReplace(screen, {\\n    src: stream.trackSid,\\n    playing: true,\\n  });\\n  console.log(`playing ${stream.identity} ${stream.sourceType} stream`);\\n}"}
{"prompt": "Register video playback events for a screen entity to monitor its playback state.", "completion": "videoEventsSystem.registerVideoEventsEntity(\\n  videoPlayerEntity,\\n  function (videoEvent) {\\n    console.log(\\n      'video event - state: ' + videoEvent.state +\\n      '\\ncurrent offset:' + videoEvent.currentOffset +\\n      '\\nvideo length:' + videoEvent.videoLength\\n    );\\n  }\\n);"}
{"prompt": "Display the same video on multiple screens by creating another screen entity and assigning it the same video texture for playback.", "completion": "const screen2 = engine.addEntity();\\nMeshRenderer.setPlane(screen2);\\nTransform.create(screen2, { position: { x: 6, y: 1, z: 4 } });\\nMaterial.setPbrMaterial(screen2, {\\n  texture: videoTexture,\\n  emissiveTexture: videoTexture,\\n  emissiveIntensity: 0.6,\\n  roughness: 1.0,\\n});"}
{"prompt": "Add an NftShape component to an entity to display a 2D token with a specific URN.", "completion": "const nft = engine.addEntity();\\nTransform.create(nft, {\\n  position: Vector3.create(8, 1, 8),\\n});\\nNftShape.create(nft, {\\n  urn: 'urn:decentraland:ethereum:erc721:0x06012c8cf97bead5deae237070f9587f8e7a266d:558536',\\n});"}
{"prompt": "Customize the frame of an NFT displayed on an entity.", "completion": "NftShape.create(nft, {\\n  urn: 'urn:decentraland:ethereum:erc721:0x06012c8cf97bead5deae237070f9587f8e7a266d:558536',\\n  color: Color3.Green(),\\n  style: NftFrameType.NFT_GOLD_EDGES,\\n});"}
{"prompt": "Trigger an NFT UI to open with details about the NFT upon a pointer down event.", "completion": "pointerEventsSystem.onPointerDown({\\n  entity: nft,\\n  opts: { button: InputAction.IA_PRIMARY, hoverText: 'Click' },\\n  function() {\\n    OpenNftDialog({\\n      urn: 'urn:decentraland:ethereum:erc721:0x06012c8cf97BEaD5deAe237070F9587f8E7A266d:558536',\\n    });\\n  }\\n});"}
{"prompt": "Explain the visual style of NFT_CLASSIC frame for an NFT.", "completion": "The NFT_CLASSIC frame style represents a traditional, elegant look often associated with classic art galleries."}
{"prompt": "Describe the NFT_BAROQUE_ORNAMENT frame style.", "completion": "The NFT_BAROQUE_ORNAMENT frame style features intricate, ornate designs typical of the Baroque period, adding a luxurious aesthetic."}
{"prompt": "What does the NFT_DIAMOND_ORNAMENT frame style look like?", "completion": "The NFT_DIAMOND_ORNAMENT frame style is characterized by sparkling, diamond-like decorations, adding a premium, glittery effect."}
{"prompt": "Define the appearance of NFT_MINIMAL_WIDE frame style.", "completion": "The NFT_MINIMAL_WIDE frame style offers a sleek, wide border that emphasizes simplicity and modernity."}
{"prompt": "Explain the NFT_MINIMAL_GREY frame style.", "completion": "The NFT_MINIMAL_GREY frame style features a simple, understated grey border, suitable for a variety of art with a focus on minimalism."}
{"prompt": "Describe the visual characteristics of NFT_BLOCKY frame style.", "completion": "The NFT_BLOCKY frame style presents a modern, geometric border with a bold, block-like appearance."}
{"prompt": "What distinguishes the NFT_GOLD_EDGES frame style?", "completion": "The NFT_GOLD_EDGES frame style is defined by its luxurious gold borders, offering a rich and elegant presentation."}
{"prompt": "Define the NFT_GOLD_CARVED frame style.", "completion": "The NFT_GOLD_CARVED frame style features elaborate gold carvings, adding a sophisticated and ornate aesthetic."}
{"prompt": "Explain the appearance of NFT_GOLD_WIDE frame style.", "completion": "The NFT_GOLD_WIDE frame style boasts a broad, gold border, combining grandeur with a modern sensibility."}
{"prompt": "Describe the NFT_GOLD_ROUNDED frame style.", "completion": "The NFT_GOLD_ROUNDED frame style offers a gold border with smooth, rounded edges for a soft, elegant look."}
{"prompt": "What does the NFT_METAL_MEDIUM frame style look like?", "completion": "The NFT_METAL_MEDIUM frame style features a medium-width metallic border, providing a sleek, industrial aesthetic."}
{"prompt": "Define the appearance of NFT_METAL_WIDE frame.", "completion": "The NFT_METAL_WIDE frame style has a broad, metallic border, emphasizing a strong, contemporary look."}
{"prompt": "Explain the NFT_METAL_SLIM frame style.", "completion": "The NFT_METAL_SLIM frame style presents a slender, metallic border, offering a refined, modern edge."}
{"prompt": "Describe the visual characteristics of NFT_METAL_ROUNDED frame style.", "completion": "The NFT_METAL_ROUNDED frame style features a metallic border with rounded corners, merging industrial appeal with softness."}
{"prompt": "What distinguishes the NFT_PINS frame style?", "completion": "The NFT_PINS frame style simulates the look of an item pinned up, adding a casual, accessible vibe to the presentation."}
{"prompt": "Define the NFT_MINIMAL_BLACK frame style.", "completion": "The NFT_MINIMAL_BLACK frame style offers a sleek, black border that complements a wide range of artworks with its understated elegance."}
{"prompt": "Explain the appearance of NFT_MINIMAL_WHITE frame style.", "completion": "The NFT_MINIMAL_WHITE frame style features a clean, white border, ideal for highlighting artwork in a crisp, light setting."}
{"prompt": "Describe the NFT_TAPE frame style.", "completion": "The NFT_TAPE frame style gives the appearance of artwork taped to the wall, adding a playful, informal touch."}
{"prompt": "What does the NFT_WOOD_SLIM frame style look like?", "completion": "The NFT_WOOD_SLIM frame style features a slim, wooden border, offering a natural, refined aesthetic."}
{"prompt": "Define the appearance of NFT_WOOD_WIDE frame.", "completion": "The NFT_WOOD_WIDE frame style has a wide, wooden border, providing a robust, earthy look to the artwork."}
{"prompt": "Explain the NFT_WOOD_TWIGS frame style.", "completion": "The NFT_WOOD_TWIGS frame style is characterized by a border made of twig-like elements, adding a rustic, organic feel."}
{"prompt": "Describe the visual characteristics of NFT_CANVAS frame style.", "completion": "The NFT_CANVAS frame style simulates the texture and look of canvas, offering an art"}
{"prompt": "Register a callback for when a clickable entity is pressed, increasing its scale.", "completion": "const clickableEntity = engine.addEntity();\\nMeshRenderer.setBox(clickableEntity);\\nMeshCollider.setBox(clickableEntity);\\nTransform.create(clickableEntity, { position: Vector3.create(8, 1, 8) });\\n\\npointerEventsSystem.onPointerDown({\\n  entity: clickableEntity,\\n  opts: { button: InputAction.IA_POINTER, hoverText: 'Click' }\\n}, function () {\\n  console.log('clicked entity');\\n  const t = Transform.getMutable(clickableEntity);\\n  t.scale.y += 0.2;\\n});"}
{"prompt": "Define a non-blocker for clicks using the MeshCollider component.", "completion": "const nonBlocker = engine.addEntity();\\nMeshRenderer.setBox(nonBlocker);\\nMeshCollider.setBox(nonBlocker, ColliderLayer.CL_PHYSICS);\\nTransform.create(nonBlocker, { position: Vector3.create(10, 1, 8) });"}
{"prompt": "Create a blocker for clicks by assigning the MeshCollider component to the CL_POINTER layer.", "completion": "const blocker = engine.addEntity();\\nMeshRenderer.setBox(blocker);\\nMeshCollider.setBox(blocker, ColliderLayer.CL_POINTER);\\nTransform.create(blocker, { position: Vector3.create(8, 1, 10) });"}
{"prompt": "Implement a system-based approach for handling input actions, logging the clicked entity's ID.", "completion": "engine.addSystem(() => {\\n  const cmd = inputSystem.getInputCommand(\\n    InputAction.IA_POINTER,\\n    PointerEventType.PET_DOWN,\\n    myEntity\\n  );\\n  if (cmd) {\\n    console.log(cmd.hit.entityId);\\n  }\\n});"}
{"prompt": "Utilize an advanced system for handling input actions, extracting and logging the hit entity's ID from pointer events.", "completion": "engine.addSystem(() => {\\n  const pointerEvents = engine.getEntitiesWith(PointerEventsResult);\\n  for (const [entity] of pointerEvents) {\\n    const pointerEventsResult = PointerEventsResult.get(entity);\\n\\n    if (pointerEventsResult.commands.length > 0) {\\n      console.log(pointerEventsResult.commands[0].hit.entityId);\\n    }\\n  }\\n});"}
{"prompt": "Register a callback to handle pointer down events on an entity, accessing the event's hit entity ID.", "completion": "pointerEventsSystem.onPointerDown({ entity: myEntity }, (cmd) => {\\n  // Access event data, e.g., cmd.hit.entityId\\n});"}
{"prompt": "Handle the event when a player pushes down a button while pointing at an entity's collider.", "completion": "pointerEventsSystem.onPointerDown({\\n  entity: targetEntity,\\n  opts: { button: InputAction.IA_POINTER, hoverText: 'Interact' }\\n}, () => {\\n  console.log('Button pressed down while pointing at the entity.');\\n});"}
{"prompt": "Detect when a player releases a button while their cursor is over an entity's collider.", "completion": "pointerEventsSystem.onPointerUp({\\n  entity: targetEntity,\\n  opts: { button: InputAction.IA_POINTER, hoverText: 'Release' }\\n}, () => {\\n  console.log('Button released while pointing at the entity.');\\n});"}
{"prompt": "Register an event for when a player's cursor enters an entity's collider area.", "completion": "pointerEventsSystem.onPointerEnter({\\n  entity: targetEntity,\\n  opts: { hoverText: 'Enter' }\\n}, () => {\\n  console.log('Cursor entered the entitys collider.');\\n});"}
{"prompt": "Handle the event when a player's cursor leaves an entity's collider area.", "completion": "pointerEventsSystem.onPointerLeave({\\n  entity: targetEntity,\\n  opts: { hoverText: 'Leave' }\\n}, () => {\\n  console.log('Cursor left the entitys collider.');\\n});"}
{"prompt": "Register a callback for click interaction on an entity and log the clicked entity's ID.", "completion": "pointerEventsSystem.onPointerDown({\\n  entity: myEntity,\\n  opts: { button: InputAction.IA_PRIMARY, hoverText: 'Interact' },\\n}, (cmd) => {\\n  console.log(`Entity ${cmd.hit.entityId} clicked`);\\n});"}
{"prompt": "Remove an interaction callback for an entity.", "completion": "pointerEventsSystem.removeOnPointerDown(myEntity);"}
{"prompt": "Handle multiple button inputs in a single callback for an entity.", "completion": "pointerEventsSystem.onPointerDown({\\n  entity: myEntity, opts: { button: InputAction.IA_ANY }},\\n  (cmd) => {\\n    if (cmd.button === InputAction.IA_POINTER) {\\n      // Handle pointer click\\n    } else if (cmd.button === InputAction.IA_PRIMARY) {\\n      // Handle primary action\\n    }\\n    // Add more conditions as needed\\n});"}
{"prompt": "Detect and handle interactions with a specific mesh within a model.", "completion": "pointerEventsSystem.onPointerDown({\\n  entity: myEntity,\\n  opts: { button: InputAction.IA_PRIMARY, hideFeedback: true },\\n}, (cmd) => {\\n  if (cmd.hit.meshName === 'firePlace') {\\n    // Specific action for mesh 'firePlace'\\n  }\\n});"}
{"prompt": "Register a global callback for pointer click events and execute global click logic.", "completion": "engine.addSystem(() => {\n  const globalClick = inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_DOWN);\n  if (globalClick) {\n    // Global click logic\n  }\n});"}
{"prompt": "Handle hover enter and hover leave events for an entity.", "completion": "engine.addSystem(() => {\n  const hoverEnter = inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_HOVER_ENTER, myEntity);\n  const hoverLeave = inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_HOVER_LEAVE, myEntity);\n  if (hoverEnter) {\n    // Hover enter logic\n  }\n  if (hoverLeave) {\n    // Hover leave logic\n  }\n});"}
{"prompt": "Detect button hold state for pointer input.", "completion": "engine.addSystem(() => {\n  const buttonPressed = inputSystem.isPressed(InputAction.IA_POINTER);\n  if (buttonPressed) {\n    // Button hold logic\n  }\n});"}
{"prompt": "Access raw data from PointerEventsResult for detailed event analysis and execute custom logic for button down event.", "completion": "engine.addSystem(() => {\\n  engine.getEntitiesWith(PointerEventsResult).forEach(([entity]) => {\\n    const eventsData = PointerEventsResult.getOrNull(entity);\\n    if (eventsData) {\\n      eventsData.commands.forEach(event => {\\n        const { analog, button, state, timestamp, hit } = event;\\n        if (state === PointerEventType.PET_DOWN && hit.entityId === entity) {\\n          // Custom logic for button down event.\\n        }\\n        // Additional conditions for hover, button up, etc, based on state.\\n      });\\n    }\\n  });\\n});"}
{"prompt": "Create a basic NPC with random appearance.", "completion": "const basicNPC = () => {\\n  const npc = engine.addEntity();\\n  AvatarShape.create(npc);\\n  Transform.create(npc, { position: Vector3.create(4, 0.25, 5) });\\n};"}
{"prompt": "Create a custom NPC with detailed configuration.", "completion": "const customNPC = (id, name, bodyShape, wearables, emotes, eyeColor, skinColor, hairColor, talking, expressionTriggerId) => {\\n  const npc = engine.addEntity();\\n  AvatarShape.create(npc, {\\n    id, name, bodyShape, wearables, emotes, eyeColor, skinColor, hairColor, talking, expressionTriggerId\\n  });\\n  Transform.create(npc, { position: Vector3.create(4, 0.25, 5) });\\n};"}
{"prompt": "Copy player's wearables to an NPC.", "completion": "const playerWearablesNPC = () => {\\n  const userData = getPlayer();\\n  if (!userData || !userData.wearables) return;\\n  const npc = engine.addEntity();\\n  AvatarShape.create(npc, {\\n    id: 'Manequin', wearables: userData.wearables\\n  });\\n  Transform.create(npc, { position: Vector3.create(4, 0.25, 5) });\\n};"}
{"prompt": "Move the player to a new relative position and set the camera target.", "completion": "movePlayerTo({\\n  newRelativePosition: Vector3.create(1, 0, 1),\\n  cameraTarget: Vector3.create(8, 1, 8),\\n});"}
{"prompt": "Create an area to hide avatars and disable passports.", "completion": "createModifierArea(Vector3.create(8, 0, 8), Vector3.create(4, 3, 4), [AvatarModifierType.AMT_HIDE_AVATARS, AvatarModifierType.AMT_DISABLE_PASSPORTS]);"}
{"prompt": "Force first-person camera mode in an area.", "completion": "createModifierArea(Vector3.create(8, 0, 8), Vector3.create(4, 3, 4), undefined, CameraType.CT_FIRST_PERSON);"}
{"prompt": "Create a basic NPC.", "completion": "createAvatar(Vector3.create(4, 0.25, 5));"}
{"prompt": "Create a custom NPC with detailed configuration.", "completion": "createAvatar(Vector3.create(4, 0.25, 5), { name: 'Custom NPC', eyeColor: Color3.Green(), expressionTriggerId: 'robot' });"}
{"prompt": "Copy player's wearables to an NPC.", "completion": "copyPlayerWearablesToNPC(Vector3.create(4, 0.25, 5));"}
{"prompt": "Trigger a default emote.", "completion": "const triggerDefaultEmote = (entity, position, emoteName, hoverText) => {\\n  Transform.create(entity, { position });\\n  MeshRenderer.setBox(entity);\\n  MeshCollider.setBox(entity);\\n  pointerEventsSystem.onPointerDown({ entity, opts: { button: InputAction.IA_POINTER, hoverText }}, () => triggerEmote({ predefinedEmote: emoteName }));\\n};"}
{"prompt": "Trigger a custom animation.", "completion": "const triggerCustomAnimation = (entity, position, animationSrc, hoverText, loop = false) => {\\n  Transform.create(entity, { position });\\n  MeshRenderer.setBox(entity);\\n  MeshCollider.setBox(entity);\\n  pointerEventsSystem.onPointerDown({ entity, opts: { button: InputAction.IA_POINTER, hoverText }}, () => triggerSceneEmote({ src: animationSrc, loop }));\\n};"}
{"prompt": "Triggering a default 'robot' emote.", "completion": "const entityForDefaultEmote = engine.addEntity();\\ntriggerDefaultEmote(entityForDefaultEmote, Vector3.create(8, 0, 8), 'robot', 'Dance');"}
{"prompt": "Triggering a custom 'Snowball_Throw' animation.", "completion": "const entityForCustomAnimation = engine.addEntity();\\ntriggerCustomAnimation(entityForCustomAnimation, Vector3.create(8, 0, 8), 'animations/Snowball_Throw.glb', 'Make snowball');"}
{"prompt": "List of default emotes available to all players in Decentraland.", "completion": "wave\nfistpump\nrobot\nraiseHand\nclap\nmoney\nkiss\ntik\nhammer\ntektonik\ndontsee\nhandsair\nshrug\ndisco\ndab\nheadexplode"}
{"prompt": "Access Decentraland time data and adjust scene ambiance based on day/night cycle.", "completion": "import { getWorldTime } from '~system/Runtime';\\nexecuteTask(async () => {\\n  const { seconds } = await getWorldTime({});\\n  // Convert seconds to hours, use for ambiance logic.\\n});"}
{"prompt": "Access realm data for multiplayer syncing in Decentraland.", "completion": "import { getRealm } from '~system/Runtime';\\nexecuteTask(async () => {\\n  const { realmInfo } = await getRealm({});\\n  // Use realmInfo for multiplayer data syncing.\\n});"}
{"prompt": "Detect player platform (Browser vs. Desktop) for platform-specific optimizations.", "completion": "import { getPlatform, Platform } from '~system/EnvironmentAPI';\\nexecuteTask(async () => {\\n  const { platform } = await getPlatform();\\n  // Adjust scene for platform capabilities.\\n});"}
{"prompt": "Access EngineInfo component for scene lifecycle data insights in Decentraland.", "completion": "import { EngineInfo } from \"@dcl/sdk/ecs\";\\nengine.addSystem(() => {\\n  const info = EngineInfo.getOrNull(engine.RootEntity);\\n  if (info) {\\n    // Use info for scene lifecycle insights.\\n  }\\n});"}
{"prompt": "Register a local direction raycast for an entity.", "completion": "raycastSystem.registerLocalDirectionRaycast({ entity, opts: { direction: Vector3.Forward() }}, raycastResult => { /* Handle result */ });"}
{"prompt": "Register a global direction raycast for an entity.", "completion": "raycastSystem.registerGlobalDirectionRaycast({ entity, opts: { direction: Vector3.Down() }}, raycastResult => { /* Handle result */ });"}
{"prompt": "Register a global target raycast for an entity.", "completion": "raycastSystem.registerGlobalTargetRaycast({ entity, opts: { globalTarget: Vector3.create(0, 0, 0) }}, raycastResult => { /* Handle result */ });"}
{"prompt": "Register a raycast against a target entity for an entity.", "completion": "raycastSystem.registerTargetEntityRaycast({ entity, opts: { targetEntity }}, raycastResult => { /* Handle result */ });"}
{"prompt": "Access raycast result for an entity and process hits.", "completion": "engine.addSystem(() => {\\n  const rayResult = RaycastResult.get(entity);\\n  if (rayResult) console.log(rayResult.hits); // Process raycast hits\\n});"}
{"prompt": "Function to access player and camera positions and rotations.", "completion": "function getPlayerAndCameraData() {\\n  if (Transform.has(engine.PlayerEntity) && Transform.has(engine.CameraEntity)) {\\n    const playerPos = Transform.get(engine.PlayerEntity).position;\\n    const playerRot = Transform.get(engine.PlayerEntity).rotation;\\n    const cameraPos = Transform.get(engine.CameraEntity).position;\\n    const cameraRot = Transform.get(engine.CameraEntity).rotation;\\n    // Log player and camera data\\n  }\\n}"}
{"prompt": "Iteration over all players and processing their data.", "completion": "for (const [entity, data, transform] of engine.getEntitiesWith(PlayerIdentityData, Transform)) {\\n  // Process each player's data\\n}"}
{"prompt": "Fetching current player data.", "completion": "let currentPlayer = getPlayer();\\nif (currentPlayer) {\\n  // Access currentPlayer data such as name, userId, isGuest, position, avatar details\\n}"}
{"prompt": "Checking player's camera mode (1st or 3rd person).", "completion": "function checkCameraMode() {\\n  const cameraMode = CameraMode.get(engine.CameraEntity).mode;\\n  // Determine if 3rd or 1st person and react accordingly\\n}"}
{"prompt": "Checking if the player's cursor is locked.", "completion": "const isCursorLocked = PointerLock.get(engine.CameraEntity).isPointerLocked;"}
{"prompt": "Teleport a player within or outside Decentraland.", "completion": "import { teleportTo } from \"~system/RestrictedActions\";\\n\\n// Teleport to specific coordinates or special keywords ('crowd', 'magic')\\nteleportTo('-51,1'); // Specific coordinates\\nteleportTo('crowd'); // Most crowded place\\nteleportTo('magic'); // Random location from curated list\\n\\n// Note: Teleports target scene spawn points, not exact coordinates."}
{"prompt": "Open an external website link in a browser window.", "completion": "import { openExternalUrl } from \"~system/RestrictedActions\";\\n\\n// Trigger only via explicit player action (click/button event)\\nopenExternalUrl(\"https://google.com\"); // Ensure full URL for external links\\n\\n// User confirmation required; domain trust option available."}
{"prompt": "Listen for player enter/leave events in the scene.", "completion": "onEnterScene(player => console.log('ENTERED SCENE', player));\\nonLeaveScene(userId => console.log('LEFT SCENE', userId));"}
{"prompt": "Query all players in the scene.", "completion": "import { getPlayersInScene } from '~system/Players';\\n// Iterate over players with PlayerIdentityData and Transform components"}
{"prompt": "Subscribe to player camera mode changes.", "completion": "import { CameraMode } from '@dcl/sdk/ecs';\\n// Subscribe to camera mode changes with CameraMode.onChange()"}
{"prompt": "Listen for player animation triggers.", "completion": "import { AvatarEmoteCommand } from '@dcl/sdk/ecs';\\n// Use AvatarEmoteCommand.onChange() to listen for emote triggers"}
{"prompt": "Monitor player profile changes such as equipped wearables and base avatar properties.", "completion": "import { AvatarEquippedData, AvatarBase } from '@dcl/sdk/ecs';\\n// Listen for changes in equipped wearables/emotes and base avatar properties"}
{"prompt": "Track changes in player's cursor lock state.", "completion": "import { PointerLock } from '@dcl/sdk/ecs';\\n// Subscribe to cursor lock state changes with PointerLock.onChange()"}
{"prompt": "Perform a REST API call.", "completion": "async function fetchFromAPI(url, options = {}) {\\n  try {\\n    const response = await fetch(url, options);\\n    return await response.json();\\n  } catch (error) {\\n    console.error('API call failed:', error);\\n  }\\n}"}
{"prompt": "Perform a signed request to an API endpoint.", "completion": "async function fetchWithSignature(url, init) {\\n  try {\\n    const response = await signedFetch({ url, init });\\n    return JSON.parse(response.statusText); // Assumes response is a stringified JSON\\n  } catch (error) {\\n    console.error('Signed fetch failed:', error);\\n  }\\n}"}
{"prompt": "Set up a WebSocket connection.", "completion": "function setupWebSocket(url) {\\n  const socket = new WebSocket(url);\\n  socket.onmessage = event => console.log('WebSocket message received:', event);\\n  // Implement other WebSocket event handlers as needed (e.g., onopen, onerror)\\n}"}
{"prompt": "Example usage: Load data from an API.", "completion": "async function loadData() {\\n  const data = await fetchFromAPI('https://example.com/data');\\n  console.log('Fetched data:', data);\\n}"}
{"prompt": "Example usage: Send data to a secure endpoint with signature.", "completion": "async function sendDataWithSignature() {\\n  const data = { /* Data to send */ };\\n  const response = await fetchWithSignature('https://example.com/secure-endpoint', {\\n    method: 'POST',\\n    headers: { 'Content-Type': 'application/json' },\\n    body: JSON.stringify(data),\\n  });\\n  console.log('Response from signed request:', response);\\n}"}
{"prompt": "Example usage: Connect to a WebSocket service.", "completion": "function connectToWebSocketService() {\\n  setupWebSocket('wss://example.com/socket');\\n}"}
{"prompt": "Synchronize a static entity with specific components and ID.", "completion": "syncEntity(staticEntity, [Transform.componentId], StaticEntityEnum.ID);"}
{"prompt": "Synchronize a dynamically created entity with specified components.", "completion": "syncEntity(dynamicEntity, [ComponentId]);"}
{"prompt": "Establish a parent-child relationship between entities.", "completion": "parentEntity(child, parent);"}
{"prompt": "Remove the parent of an entity and query its relationships.", "completion": "removeParent(child);\\nconst parent = getParent(child);\\nconst children = getChildren(parent);"}
{"prompt": "Utilize MessageBus for custom synchronization between entities.", "completion": "const sceneMessageBus = new MessageBus();\\n\\n// Sending a message\\nsceneMessageBus.emit('eventType', { key: 'value' });\\n\\n// Handling received messages\\nsceneMessageBus.on('eventType', ({ key }) => {\\n    // Response to the message\\n});"}
